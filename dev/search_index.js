var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/#Types","page":"API reference","title":"Types","text":"","category":"section"},{"location":"api/#RadialCalderon.ForwardProblem","page":"API reference","title":"RadialCalderon.ForwardProblem","text":"struct ForwardProblem\n\nContainer for the forward Calderon problem\n\nFields\n\nn::Integer: number of annuli\nradii::Vector: inner radii\n\n\n\n\n\n","category":"type"},{"location":"api/#RadialCalderon.ConvexCalderonProblem","page":"API reference","title":"RadialCalderon.ConvexCalderonProblem","text":"struct ConvexCalderonProblem\n\nContainer for the convex nonlinear SDP problem\n\nFields\n\nc::Vector: weight vector\na::Number: conductivity lower bound\nb::Number: conductivity upper bound\nobs::Vector: observations\nforward::ForwardProblem: forward problem\n\n\n\n\n\n","category":"type"},{"location":"api/#Resolution","page":"API reference","title":"Resolution","text":"","category":"section"},{"location":"api/#RadialCalderon.estimate_c","page":"API reference","title":"RadialCalderon.estimate_c","text":"estimate_c(σ, a, b, m, forward; max_last_coord, quiet)\n\n\nEstimate the weight vector defining the objective of the convex nonlinear SDP problem.\n\n\n\n\n\n","category":"function"},{"location":"examples/forward/#Evaluating-the-forward-map-and-its-derivatives","page":"Forward map","title":"Evaluating the forward map and its derivatives","text":"","category":"section"},{"location":"examples/forward/","page":"Forward map","title":"Forward map","text":"Here we show how to evaluate the forward map associated to the Calderon problem with radial piecewise constant conductivities. We also show how to evaluate its derivatives via automatic differentiation.","category":"page"},{"location":"examples/forward/","page":"Forward map","title":"Forward map","text":"using RadialCalderon","category":"page"},{"location":"examples/forward/#Setting","page":"Forward map","title":"Setting","text":"","category":"section"},{"location":"examples/forward/","page":"Forward map","title":"Forward map","text":"We define the forward problem. There are three annuli with the inner radii being 0.5 and 0.25.","category":"page"},{"location":"examples/forward/","page":"Forward map","title":"Forward map","text":"n = 3\nr = [0.5, 0.25]\nforward = ForwardProblem(r);\nnothing #hide","category":"page"},{"location":"examples/forward/#Forward-map","page":"Forward map","title":"Forward map","text":"","category":"section"},{"location":"examples/forward/","page":"Forward map","title":"Forward map","text":"We define the (diagonal) Neumann-to-Dirichlet map associated to the boundary data (mathrmcos(jtheta))_1leq jleq m.","category":"page"},{"location":"examples/forward/","page":"Forward map","title":"Forward map","text":"m = 5\nλ(j, σ) = forward_map(forward, j, σ)\nΛ(σ) = [λ(j, σ) for j in 1:m];\nnothing #hide","category":"page"},{"location":"examples/forward/#Derivatives","page":"Forward map","title":"Derivatives","text":"","category":"section"},{"location":"examples/forward/","page":"Forward map","title":"Forward map","text":"The first and second order derivatives of Lambda can be computed via automatic differentiation.","category":"page"},{"location":"examples/forward/","page":"Forward map","title":"Forward map","text":"using DifferentiationInterface\nimport ForwardDiff\n\nbackend = AutoForwardDiff()\n\ndΛ(σ) = jacobian(Λ, backend, σ)  # Jacobian of the forward map\ngrad_λ(j, σ) = gradient(σ -> λ(j, σ), backend, σ)  # gradient of the j-th output\nhess_λ(j, σ) = hessian(σ -> λ(j, σ), backend, σ)  # Hessian of the j-th output\n\ndΛ(ones(n))","category":"page"},{"location":"examples/forward/#Closed-form-expression","page":"Forward map","title":"Closed form expression","text":"","category":"section"},{"location":"examples/forward/","page":"Forward map","title":"Forward map","text":"When n=3 and the conductivity is equal to 1 on the outermost annulus, the forward map has the following closed form expression (Harrach, 2023):","category":"page"},{"location":"examples/forward/","page":"Forward map","title":"Forward map","text":"λ_j(σ_1σ_2)=fracc_j+d_jj(c_j-d_j)","category":"page"},{"location":"examples/forward/","page":"Forward map","title":"Forward map","text":"where","category":"page"},{"location":"examples/forward/","page":"Forward map","title":"Forward map","text":"c_j=(1σ_1+1)(σ_1+σ_2) + (1σ_1-1)(σ_1-σ_2)r_2^2jr_1^2j","category":"page"},{"location":"examples/forward/","page":"Forward map","title":"Forward map","text":"d_j=(1σ_1-1)(σ_1+σ_2)r_1^2j + (1σ_1+1)(σ_1-σ_2)r_2^2j","category":"page"},{"location":"examples/forward/","page":"Forward map","title":"Forward map","text":"We check the consistency of the implemented forward map with this formula.","category":"page"},{"location":"examples/forward/","page":"Forward map","title":"Forward map","text":"σ1 = 1.5\nσ2 = 0.5\nσ = [1.0, σ1, σ2]\n\nc(j) = (1/σ1+1)*(σ1+σ2) + (1/σ1-1)*(σ1-σ2)*r[2]^(2*j)/r[1]^(2*j)\nd(j) = (1/σ1-1)*(σ1+σ2)*r[1]^(2*j) + (1/σ1+1)*(σ1-σ2)*r[2]^(2*j)\n\n@info forward_map(forward, 1, σ) ≈ (c(1)+d(1)) / (c(1)-d(1))\n@info forward_map(forward, 2, σ) ≈ (c(2)+d(2)) / (2*(c(2)-d(2)))\n@info forward_map(forward, 3, σ) ≈ (c(3)+d(3)) / (3*(c(3)-d(3)))","category":"page"},{"location":"examples/forward/#References","page":"Forward map","title":"References","text":"","category":"section"},{"location":"examples/forward/","page":"Forward map","title":"Forward map","text":"Harrach, B. (2023). The Calderón Problem with Finitely Many Unknowns Is Equivalent to Convex Semidefinite Optimization. SIAM Journal on Mathematical Analysis, 5666–5684.\n\n\n\n","category":"page"},{"location":"examples/forward/","page":"Forward map","title":"Forward map","text":"","category":"page"},{"location":"examples/forward/","page":"Forward map","title":"Forward map","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#RadialCalderon.jl","page":"Home","title":"RadialCalderon.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Dev) (Image: Aqua QA) (Image: Build Status)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A Julia package for studying the Calderon problem with piecewise constant radial conductivities.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install this package, run the following command from the REPL in Pkg mode.","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/rpetit/RadialCalderon.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Tutorials and examples are available in the documentation.","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use this package in your research, please cite the following preprint.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{ClariceGiovanniRomain2025,\n    title = {Numerical study of a convex programming approach to the Calder{\\'o}n problem},\n    author = {Clarice, Giovanni, Romain},\n    year = {2025},\n    number = {arXiv:0000.00000},\n    eprint = {0000.00000},\n    primaryclass = {math},\n    publisher = {arXiv}\n}","category":"page"},{"location":"examples/nonlinear_sdp/#Reconstruction-via-convex-programming","page":"Nonlinear SDP","title":"Reconstruction via convex programming","text":"","category":"section"},{"location":"examples/nonlinear_sdp/","page":"Nonlinear SDP","title":"Nonlinear SDP","text":"In this tutorial, we show how to implement in practice the reconstruction method introduced in (Harrach, 2023). It is based on the resolution of a convex nonlinear semidefinite program of the form","category":"page"},{"location":"examples/nonlinear_sdp/","page":"Nonlinear SDP","title":"Nonlinear SDP","text":"undersetsigmainab^nmathrmminlangle csigmaranglemathrmstLambda(sigma)leq y","category":"page"},{"location":"examples/nonlinear_sdp/","page":"Nonlinear SDP","title":"Nonlinear SDP","text":"where c is a weight vector with positive entries and y is the vector of observations. If the number of measurements m is large enough, then there exists a vector c such that, for every sigma^daggerinab^n, the above problem with y=Lambda(sigma^dagger) has a unique solution which is sigma^dagger.","category":"page"},{"location":"examples/nonlinear_sdp/#Setting","page":"Nonlinear SDP","title":"Setting","text":"","category":"section"},{"location":"examples/nonlinear_sdp/","page":"Nonlinear SDP","title":"Nonlinear SDP","text":"We define the forward problem. There are two annuli with the inner radius being 0.5.","category":"page"},{"location":"examples/nonlinear_sdp/","page":"Nonlinear SDP","title":"Nonlinear SDP","text":"using RadialCalderon\n\nn = 2\nr = [0.5]\nforward = ForwardProblem(r)\n\na = 0.5\nb = 1.5;\nnothing #hide","category":"page"},{"location":"examples/nonlinear_sdp/#Estimation-of-the-weight-vector","page":"Nonlinear SDP","title":"Estimation of the weight vector","text":"","category":"section"},{"location":"examples/nonlinear_sdp/","page":"Nonlinear SDP","title":"Nonlinear SDP","text":"For a given m, one can rely on the function estimate_c to try to find a universal vector c. Below, we check that, when n=2, this is possible for m=3 but not for m=2. First, we define a set of conductivities which will be used to estimate c.","category":"page"},{"location":"examples/nonlinear_sdp/","page":"Nonlinear SDP","title":"Nonlinear SDP","text":"using Base.Iterators: product\n\nk = 2\n\nprod_it = product([range(a, b, k) for i=1:forward.n]...)\nσ = hcat(collect.(collect(prod_it))...)\nσ = σ[:, 1:end-1];  # remove b*ones(n)\nnothing #hide","category":"page"},{"location":"examples/nonlinear_sdp/","page":"Nonlinear SDP","title":"Nonlinear SDP","text":"We check that there is no admissible vector c for m=2.","category":"page"},{"location":"examples/nonlinear_sdp/","page":"Nonlinear SDP","title":"Nonlinear SDP","text":"using JuMP: is_solved_and_feasible\n\nm = 2\nc, model = estimate_c(σ, a, b, m, forward)\n@info is_solved_and_feasible(model)","category":"page"},{"location":"examples/nonlinear_sdp/","page":"Nonlinear SDP","title":"Nonlinear SDP","text":"We check that there is an admissible vector c for m=3.","category":"page"},{"location":"examples/nonlinear_sdp/","page":"Nonlinear SDP","title":"Nonlinear SDP","text":"m = 3\nc, model = estimate_c(σ, a, b, m, forward)\n@info is_solved_and_feasible(model)\n@info c","category":"page"},{"location":"examples/nonlinear_sdp/#Resolution-of-the-convex-nonlinear-SDP","page":"Nonlinear SDP","title":"Resolution of the convex nonlinear SDP","text":"","category":"section"},{"location":"examples/nonlinear_sdp/","page":"Nonlinear SDP","title":"Nonlinear SDP","text":"TODO","category":"page"},{"location":"examples/nonlinear_sdp/#References","page":"Nonlinear SDP","title":"References","text":"","category":"section"},{"location":"examples/nonlinear_sdp/","page":"Nonlinear SDP","title":"Nonlinear SDP","text":"Harrach, B. (2023). The Calderón Problem with Finitely Many Unknowns Is Equivalent to Convex Semidefinite Optimization. SIAM Journal on Mathematical Analysis, 5666–5684.\n\n\n\n","category":"page"},{"location":"examples/nonlinear_sdp/","page":"Nonlinear SDP","title":"Nonlinear SDP","text":"","category":"page"},{"location":"examples/nonlinear_sdp/","page":"Nonlinear SDP","title":"Nonlinear SDP","text":"This page was generated using Literate.jl.","category":"page"}]
}
